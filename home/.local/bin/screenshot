#!/bin/bash

[[ -f ~/.config/user-dirs.dirs ]] && source ~/.config/user-dirs.dirs
OUTPUT_DIR="${XDG_PICTURES_DIR:-$HOME/Pictures/}"

if [[ ! -d $OUTPUT_DIR ]]; then
  notify-send "Pictures directory does not exist: $OUTPUT_DIR" -u critical -t 3000
  exit 1
fi

pkill slurp && exit 0

JQ_MONITOR_GEO='
  def format_geo:
    .x as $x | .y as $y |
    (.width / .scale | floor) as $w |
    (.height / .scale | floor) as $h |
    .transform as $t |
    if $t == 1 or $t == 3 then
      "\($x),\($y) \($h)x\($w)"
    else
      "\($x),\($y) \($w)x\($h)"
    end;
'

get_rectangles() {
  local active_workspaces=$(hyprctl monitors -j | jq -r '[.[] | .activeWorkspace.id] | unique | join(",")')
  hyprctl monitors -j | jq -r --arg ws "$active_workspaces" "${JQ_MONITOR_GEO} .[] | select([.activeWorkspace.id] | inside(\$ws | split(\",\") | map(tonumber))) | format_geo"

  local fullscreen_workspaces=$(hyprctl clients -j | jq -r '[.[] | select(.fullscreen != 0) | .workspace.id] | unique | join(",")')

  hyprctl clients -j | jq -r --arg ws "$active_workspaces" --arg fs_ws "$fullscreen_workspaces" '
    ($fs_ws | split(",") | map(tonumber)) as $fullscreen_ws_array |
    ($ws | split(",") | map(tonumber)) as $active_ws_array |
    .[] |
    select([.workspace.id] | inside($active_ws_array)) |
    .workspace.id as $ws_id |
    select(
      if ($fullscreen_ws_array | contains([$ws_id])) then
        .fullscreen != 0
      else
        true
      end
    ) |
    "\(.at[0]),\(.at[1]) \(.size[0])x\(.size[1])"'
}

MODE=$1

# Select based on mode
case "$MODE" in
  region)
    hyprpicker -r -z >/dev/null 2>&1 & PID=$!
    sleep .1
    SELECTION=$(slurp 2>/dev/null)
    kill $PID 2>/dev/null
    ;;
  windows)
    hyprpicker -r -z >/dev/null 2>&1 & PID=$!
    sleep .1
    SELECTION=$(get_rectangles | slurp -r 2>/dev/null)
    kill $PID 2>/dev/null
    ;;
  fullscreen)
    SELECTION=$(hyprctl monitors -j | jq -r "${JQ_MONITOR_GEO} .[] | select(.focused == true) | format_geo")
    ;;
  smart|*)
    RECTS=$(get_rectangles)
    hyprpicker -r -z >/dev/null 2>&1 & PID=$!
    sleep .1
    SELECTION=$(echo "$RECTS" | slurp 2>/dev/null)
    kill $PID 2>/dev/null

  # If the selection area is L * W < 20, we'll assume you were trying to select whichever
  # window or output it was inside of to prevent accidental 2px snapshots
  if [[ $SELECTION =~ ^([0-9]+),([0-9]+)[[:space:]]([0-9]+)x([0-9]+)$ ]]; then
    if ((${BASH_REMATCH[3]} * ${BASH_REMATCH[4]} < 20)); then
      click_x="${BASH_REMATCH[1]}"
      click_y="${BASH_REMATCH[2]}"

      while IFS= read -r rect; do
        if [[ $rect =~ ^([0-9]+),([0-9]+)[[:space:]]([0-9]+)x([0-9]+) ]]; then
          rect_x="${BASH_REMATCH[1]}"
          rect_y="${BASH_REMATCH[2]}"
          rect_width="${BASH_REMATCH[3]}"
          rect_height="${BASH_REMATCH[4]}"

          if ((click_x >= rect_x && click_x < rect_x + rect_width && click_y >= rect_y && click_y < rect_y + rect_height)); then
            SELECTION="${rect_x},${rect_y} ${rect_width}x${rect_height}"
            break
          fi
        fi
      done <<<"$RECTS"
    fi
  fi
  ;;
esac

[[ -z $SELECTION ]] && exit 0

FILENAME="Screenshot-$(date +'%Y-%m-%d-at-%I.%M.%S%p').png"
FILEPATH="$OUTPUT_DIR/Screenshots/$FILENAME"
mkdir -p $OUTPUT_DIR/Screenshots

grim -g "$SELECTION" "$FILEPATH" || exit 1
wl-copy <"$FILEPATH"

notify-send "Screenshot saved to clipboard and file" -t 10000 -i "$FILEPATH" &

# vim: ft=sh
